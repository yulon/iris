<html>

<head>
<meta charset="utf-8">
<style>
	body {
		background-color: #E5E5E5;
		text-align: center;
		font-family: "Segoe UI","Lucida Grande",Helvetica,Arial,"Microsoft YaHei",FreeSans,Arimo,"Droid Sans","wenquanyi micro hei","Hiragino Sans GB","Hiragino Sans GB W3",sans-serif;
	}
	#cav {
		background-color: #000000;
		box-shadow: 0px 5px 50px rgba(0, 0, 0, 0.8);
	}

</style>

<script src="minMatrix.js"></script>
<script src="mlang.js"></script>
<script src="j5.js"></script>

		<script id="vs" type="x-shader/x-vertex">
			attribute vec3 position;
			attribute vec4 color;
			uniform   mat4 mvpMatrix;
			varying   vec4 vColor;

			void main(void){
				vColor = color;
				gl_Position = mvpMatrix * vec4(position, 1.0);
			}
		</script>
		
		<script id="fs" type="x-shader/x-fragment">
			precision mediump float;

			varying vec4 vColor;

			void main(void){
				gl_FragColor = vColor;
			}
		</script>
</head>

<body>
	<canvas id="cav" width="700" height="600"></canvas>
	<script>
		var c = document.getElementById("cav");
		var gl = c.getContext("webgl") || c.getContext('experimental-webgl');

		var v_shader = create_shader('vs');
		var f_shader = create_shader('fs');
		
		// 产生和链接程序对象
		var prg = create_program(v_shader, f_shader);
		
		// 获取attributeLocation阵列
		var attLocation = new Array(2);
		attLocation[0] = gl.getAttribLocation(prg, 'position');
		attLocation[1] = gl.getAttribLocation(prg, 'color');
		
		// 存储在attribute的元素数为数组
		var attStride = new Array(2);
		attStride[0] = 3;
		attStride[1] = 4;
		
		// 数组来存储顶点属性
		var position = [
			 0.0, 1.0, 0.0,
			 1.0, 0.0, 0.0,
			-1.0, 0.0, 0.0
		];
		var color = [
			1.0, 1.0, 1.0, 1.0,
			1.0, 1.0, 1.0, 1.0,
			1.0, 1.0, 1.0, 1.0
		];
		
		// VBOの生成
		var pos_vbo = create_vbo(position);
		var col_vbo = create_vbo(color);
		
		// VBO を登録する
		set_attribute([pos_vbo, col_vbo], attLocation, attStride);
		
		// uniformLocationの取得
		var uniLocation = gl.getUniformLocation(prg, 'mvpMatrix');
		
		// 矩阵相关的使用处理minMatrix.js
		// 产生matIV对象
		var m = new matIV();
		
		// 生成和各种矩阵初始化
		var mMatrix = m.identity(m.create());
		var vMatrix = m.identity(m.create());
		var pMatrix = m.identity(m.create());
		var tmpMatrix = m.identity(m.create());
		var mvpMatrix = m.identity(m.create());
		
		// 查看×投影坐标变换矩阵
		m.lookAt([0.0, 0.0, 5.0], [0, 0, 0], [0, 1, 0], vMatrix);
		m.perspective(85, c.width / c.height, 0.1, 100, pMatrix);
		m.multiply(pMatrix, vMatrix, tmpMatrix);
		
		// カウンタの宣言
		var count = 0;
		
		// 恒常ループ
		(function(){
			// canvasを初期化
			gl.clearColor(0.0, 0.0, 0.0, 1.0);
			gl.clearDepth(1.0);
			gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
			
			// 我递增计数器
			count++;
			
			// 计数器计算的弧度到原来的
			var rad = (count % 360) * Math.PI / 180;
			
			var x = Math.cos(rad);
			var y = Math.sin(rad);
			var s = Math.sin(rad) + 1.0;
			m.identity(mMatrix);
			m.translate(mMatrix, [0, 0, 2], mMatrix);
			//m.rotate(mMatrix, rad, [0, 1, 0], mMatrix);
			m.multiply(tmpMatrix, mMatrix, mvpMatrix);
			gl.uniformMatrix4fv(uniLocation, false, mvpMatrix);
			gl.drawArrays(gl.TRIANGLES, 0, 3);
			
			// 上下文重绘
			gl.flush();
			
			// 递归调用for循环
			setTimeout(arguments.callee, 1000 / 30);
		})();
		
		// シェーダを生成する関数
		function create_shader(id){
			// シェーダを格納する変数
			var shader;
			
			// HTMLからscriptタグへの参照を取得
			var scriptElement = document.getElementById(id);
			
			// scriptタグが存在しない場合は抜ける
			if(!scriptElement){return;}
			
			// scriptタグのtype属性をチェック
			switch(scriptElement.type){
				
				// 頂点シェーダの場合
				case 'x-shader/x-vertex':
					shader = gl.createShader(gl.VERTEX_SHADER);
					break;
					
				// フラグメントシェーダの場合
				case 'x-shader/x-fragment':
					shader = gl.createShader(gl.FRAGMENT_SHADER);
					break;
				default :
					return;
			}
			
			// 生成されたシェーダにソースを割り当てる
			gl.shaderSource(shader, scriptElement.text);
			
			// シェーダをコンパイルする
			gl.compileShader(shader);
			
			// シェーダが正しくコンパイルされたかチェック
			if(gl.getShaderParameter(shader, gl.COMPILE_STATUS)){
				
				// 成功していたらシェーダを返して終了
				return shader;
			}else{
				
				// 失敗していたらエラーログをアラートする
				alert(gl.getShaderInfoLog(shader));
			}
		}
		
		// プログラムオブジェクトを生成しシェーダをリンクする関数
		function create_program(vs, fs){
			// プログラムオブジェクトの生成
			var program = gl.createProgram();
			
			// プログラムオブジェクトにシェーダを割り当てる
			gl.attachShader(program, vs);
			gl.attachShader(program, fs);
			
			// シェーダをリンク
			gl.linkProgram(program);
			
			// シェーダのリンクが正しく行なわれたかチェック
			if(gl.getProgramParameter(program, gl.LINK_STATUS)){
			
				// 成功していたらプログラムオブジェクトを有効にする
				gl.useProgram(program);
				
				// プログラムオブジェクトを返して終了
				return program;
			}else{
				
				// 失敗していたらエラーログをアラートする
				alert(gl.getProgramInfoLog(program));
			}
		}
		
		// VBOを生成する関数
		function create_vbo(data){
			// バッファオブジェクトの生成
			var vbo = gl.createBuffer();
			
			// バッファをバインドする
			gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
			
			// バッファにデータをセット
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW);
			
			// バッファのバインドを無効化
			gl.bindBuffer(gl.ARRAY_BUFFER, null);
			
			// 生成した VBO を返して終了
			return vbo;
		}
		
		// VBOをバインドし登録する関数
		function set_attribute(vbo, attL, attS){
			// 引数として受け取った配列を処理する
			for(var i in vbo){
				// バッファをバインドする
				gl.bindBuffer(gl.ARRAY_BUFFER, vbo[i]);
				
				// attributeLocationを有効にする
				gl.enableVertexAttribArray(attL[i]);
				
				// attributeLocationを通知し登録する
				gl.vertexAttribPointer(attL[i], attS[i], gl.FLOAT, false, 0, 0);
			}
		}
	</script>
</body>

</html>